{"version":3,"sources":["../node_modules/crc-32/crc32.js","../node_modules/png-chunks-extract/index.js"],"names":["Buffer","factory","CRC32","version","table","c","Array","n","Int32Array","signed_crc_table","use_buffer","crc32_buf_8","buf","crc","i","L","length","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC","exports","crc32","__webpack_require__","module","data","Error","ended","chunks","idx","uint8","uint32","chunk","Uint8Array","name","String","fromCharCode","push","crcActual","int32","crcExpect","chunkData","buffer","slice","Uint32Array"],"mappings":"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","file":"static/js/209.829a9113.chunk.js","sourcesContent":["/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n\n/* vim: set ts=2: */\nvar CRC32;\n\n(function (factory) {\n  if (typeof DO_NOT_EXPORT_CRC === 'undefined') {\n    if ('object' === typeof exports) {\n      factory(exports);\n    } else if ('function' === typeof define && define.amd) {\n      define(function () {\n        var module = {};\n        factory(module);\n        return module;\n      });\n    } else {\n      factory(CRC32 = {});\n    }\n  } else {\n    factory(CRC32 = {});\n  }\n})(function (CRC32) {\n  CRC32.version = '0.3.0';\n  /* see perf/crc32table.js */\n\n  function signed_crc_table() {\n    var c = 0,\n        table = new Array(256);\n\n    for (var n = 0; n != 256; ++n) {\n      c = n;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      table[n] = c;\n    }\n\n    return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n  }\n\n  var table = signed_crc_table();\n  /* charCodeAt is the best approach for binary strings */\n\n  var use_buffer = typeof Buffer !== 'undefined';\n\n  function crc32_bstr(bstr) {\n    if (bstr.length > 32768) if (use_buffer) return crc32_buf_8(new Buffer(bstr));\n    var crc = -1,\n        L = bstr.length - 1;\n\n    for (var i = 0; i < L;) {\n      crc = table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ crc >>> 8;\n      crc = table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ crc >>> 8;\n    }\n\n    if (i === L) crc = crc >>> 8 ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n    return crc ^ -1;\n  }\n\n  function crc32_buf(buf) {\n    if (buf.length > 10000) return crc32_buf_8(buf);\n\n    for (var crc = -1, i = 0, L = buf.length - 3; i < L;) {\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n    }\n\n    while (i < L + 3) {\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n    }\n\n    return crc ^ -1;\n  }\n\n  function crc32_buf_8(buf) {\n    for (var crc = -1, i = 0, L = buf.length - 7; i < L;) {\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n    }\n\n    while (i < L + 7) {\n      crc = crc >>> 8 ^ table[(crc ^ buf[i++]) & 0xFF];\n    }\n\n    return crc ^ -1;\n  }\n  /* much much faster to intertwine utf8 and crc */\n\n\n  function crc32_str(str) {\n    for (var crc = -1, i = 0, L = str.length, c, d; i < L;) {\n      c = str.charCodeAt(i++);\n\n      if (c < 0x80) {\n        crc = crc >>> 8 ^ table[(crc ^ c) & 0xFF];\n      } else if (c < 0x800) {\n        crc = crc >>> 8 ^ table[(crc ^ (192 | c >> 6 & 31)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | c & 63)) & 0xFF];\n      } else if (c >= 0xD800 && c < 0xE000) {\n        c = (c & 1023) + 64;\n        d = str.charCodeAt(i++) & 1023;\n        crc = crc >>> 8 ^ table[(crc ^ (240 | c >> 8 & 7)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | c >> 2 & 63)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | d >> 6 & 15 | c & 3)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | d & 63)) & 0xFF];\n      } else {\n        crc = crc >>> 8 ^ table[(crc ^ (224 | c >> 12 & 15)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | c >> 6 & 63)) & 0xFF];\n        crc = crc >>> 8 ^ table[(crc ^ (128 | c & 63)) & 0xFF];\n      }\n    }\n\n    return crc ^ -1;\n  }\n\n  CRC32.table = table;\n  CRC32.bstr = crc32_bstr;\n  CRC32.buf = crc32_buf;\n  CRC32.str = crc32_str;\n});","var crc32 = require('crc-32');\n\nmodule.exports = extractChunks; // Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\n\nvar uint8 = new Uint8Array(4);\nvar int32 = new Int32Array(uint8.buffer);\nvar uint32 = new Uint32Array(uint8.buffer);\n\nfunction extractChunks(data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header');\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header');\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header');\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header');\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header');\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?');\n  var ended = false;\n  var chunks = [];\n  var idx = 8;\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++]; // Chunk includes name/type for CRC check (see below).\n\n    var length = uint32[0] + 4;\n    var chunk = new Uint8Array(length);\n    chunk[0] = data[idx++];\n    chunk[1] = data[idx++];\n    chunk[2] = data[idx++];\n    chunk[3] = data[idx++]; // Get the name in ASCII for identification.\n\n    var name = String.fromCharCode(chunk[0]) + String.fromCharCode(chunk[1]) + String.fromCharCode(chunk[2]) + String.fromCharCode(chunk[3]); // The IHDR header MUST come first.\n\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing');\n    } // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n\n\n    if (name === 'IEND') {\n      ended = true;\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      });\n      break;\n    } // Read the contents of the chunk out of the main buffer.\n\n\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++];\n    } // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n\n\n    uint8[3] = data[idx++];\n    uint8[2] = data[idx++];\n    uint8[1] = data[idx++];\n    uint8[0] = data[idx++];\n    var crcActual = int32[0];\n    var crcExpect = crc32.buf(chunk);\n\n    if (crcExpect !== crcActual) {\n      throw new Error('CRC values for ' + name + ' header do not match, PNG file is likely corrupted');\n    } // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n\n\n    var chunkData = new Uint8Array(chunk.buffer.slice(4));\n    chunks.push({\n      name: name,\n      data: chunkData\n    });\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found');\n  }\n\n  return chunks;\n}"],"sourceRoot":""}